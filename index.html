<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>オセロ</title>
<style>
html,body{margin:0;padding:0;height:100%;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  background:linear-gradient(to bottom,#f0f0f3,#d7d7db);}
body{display:flex;flex-direction:column;}
#top-panel{padding:4px;flex:0 0 auto;}
.controls-row{display:flex;justify-content:center;gap:6px;margin-bottom:4px;flex-wrap:wrap}
select,button{padding:6px 10px;font-size:14px;border:1px solid rgba(0,0,0,0.15);
border-radius:10px;background:rgba(255,255,255,0.7);touch-action:manipulation;}
.strategy-group{display:flex;flex-wrap:wrap;justify-content:center;gap:6px;}
.strategy-btn{padding:6px 10px;font-size:13px;border:1px solid rgba(0,0,0,0.2);
border-radius:10px;background:rgba(255,255,255,0.7);}
.strategy-btn.active{background:rgba(0,122,255,0.85);color:#fff;}
#board-container{flex:1 1 auto;display:flex;justify-content:center;align-items:center;padding:4px;}
#board{display:grid;gap:1px;border-radius:16px;background-color:#1e824c;
background-image:linear-gradient(#1e824c 1px,transparent 1px),
linear-gradient(90deg,#1e824c 1px,transparent 1px);
box-shadow:0 4px 12px rgba(0,0,0,0.2);}
.cell{background:#27ae60;border-radius:4px;position:relative;}
.disk{border-radius:50%;position:absolute;}
.black{background:#000;}
.white{background:#fff;}
.hint-dot{position:absolute;border-radius:50%;background:rgba(0,0,0,0.7);}
.last-move{outline:3px solid yellow;outline-offset:-3px;}
.overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
  font-weight:bold;font-size:20px;border-radius:4px}
.rank1{background:rgba(0,255,0,0.35);}
.rank2{background:rgba(0,255,0,0.25);}
.rank3{background:rgba(0,255,0,0.15);}
.bad{background:rgba(255,0,0,0.25);}
.label{background:rgba(255,255,255,0.8);border-radius:9999px;padding:2px 8px;}
.label.bad{color:#c00;}
#score{margin:4px;text-align:center;}
</style>
</head>
<body>
  <div id="top-panel">
    <div class="controls-row">
      <select id="mode">
        <option value="pvp">プレイヤー vs プレイヤー</option>
        <option value="cpu">プレイヤー vs CPU</option>
      </select>
      <button id="undoBtn">1手前に戻る</button>
      <button id="resetBtn">最初に戻す</button>
    </div>
    <div class="controls-row">
      <select id="depth" title="強さ（読みの深さ）">
        <option value="1">弱い</option>
        <option value="2" selected>普通</option>
        <option value="3">強い</option>
      </select>
      <select id="hintSide" title="提案対象">
        <option value="none">提案なし</option>
        <option value="first">黒(先手)が提案</option>
        <option value="second">白(後手)が提案</option>
      </select>
    </div>
    <div class="strategy-group">
      <button class="strategy-btn active" data-strategy="balance">バランス</button>
      <button class="strategy-btn" data-strategy="mobility">相手の手を減らす</button>
      <button class="strategy-btn" data-strategy="corner">角を取る</button>
      <button class="strategy-btn" data-strategy="count">石数優先</button>
    </div>
    <div id="score"></div>
  </div>

  <div id="board-container"><div id="board"></div></div>

<script>
window.onload=function(){
  const SIZE=8, INF=1e9;
  const firstPlayer='black';
  let board, currentPlayer, mode, cpuDepth, hintSide;
  let strategy='balance';
  let overlayHints=[];
  let history=[];
  let lastMove=null;

  function resizeBoard(){
    const bw=Math.min(window.innerWidth*0.95, 380);
    const boardDiv=document.getElementById('board');
    boardDiv.style.width=bw+'px';
    boardDiv.style.height=bw+'px';
    boardDiv.style.gridTemplateColumns=`repeat(${SIZE}, ${bw/SIZE}px)`;
    boardDiv.style.gridTemplateRows=`repeat(${SIZE}, ${bw/SIZE}px)`;
  }
  function initBoard(){
    board=Array.from({length:SIZE},()=>Array(SIZE).fill(null));
    board[3][3]='white'; board[3][4]='black';
    board[4][3]='black'; board[4][4]='white';
    history=[]; overlayHints=[]; lastMove=null;
  }
  function cloneBoard(b){return b.map(row=>row.slice());}
  function dirs(){return [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,1],[-1,1],[1,-1]];}

  function validMoves(player,b=board){
    const opp = player==='black'?'white':'black';
    const moves=[];
    for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
      if(b[r][c]) continue;
      for(const [dr,dc] of dirs()){
        let nr=r+dr, nc=c+dc, seenOpp=false;
        while(nr>=0&&nr<SIZE&&nc>=0&&nc<SIZE&&b[nr][nc]===opp){
          seenOpp=true; nr+=dr; nc+=dc;
        }
        if(seenOpp && nr>=0&&nr<SIZE&&nc>=0&&nc<SIZE && b[nr][nc]===player){
          moves.push([r,c]); break;
        }
      }
    }
    return moves;
  }
  function applyMove(r,c,player,b=board){
    const opp = player==='black'?'white':'black';
    b[r][c]=player;
    for(const [dr,dc] of dirs()){
      let nr=r+dr, nc=c+dc, path=[];
      while(nr>=0&&nr<SIZE&&nc>=0&&nc<SIZE&&b[nr][nc]===opp){
        path.push([nr,nc]); nr+=dr; nc+=dc;
      }
      if(path.length && nr>=0&&nr<SIZE&&nc>=0&&nc<SIZE && b[nr][nc]===player){
        for(const [rr,cc] of path) b[rr][cc]=player;
      }
    }
  }
  function countFlips(b,r,c,player){
    const opp = player==='black'?'white':'black';
    let flips=0;
    for(const [dr,dc] of dirs()){
      let nr=r+dr, nc=c+dc, path=0;
      while(nr>=0&&nr<SIZE&&nc>=0&&nc<SIZE&&b[nr][nc]===opp){
        path++; nr+=dr; nc+=dc;
      }
      if(path>0 && nr>=0&&nr<SIZE&&nc>=0&&nc<SIZE && b[nr][nc]===player) flips+=path;
    }
    return flips;
  }

  function score_balance(b, root){
    let s=0;
    for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
      if(b[r][c]===root) s++;
      else if(b[r][c]) s--;
    }
    return s;
  }
  function score_corner(b, root){
    const corners=[[0,0],[0,SIZE-1],[SIZE-1,0],[SIZE-1,SIZE-1]];
    let s=score_balance(b, root);
    for(const [r,c] of corners){
      if(b[r][c]===root) s+=8;
      else if(b[r][c]) s-=8;
    }
    return s;
  }
  function score_mobility(b, root){
    const opp = root==='black'?'white':'black';
    return validMoves(root,b).length - 3*validMoves(opp,b).length;
  }
  function score_count(b, root){
    let s=0;
    for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
      if(b[r][c]===root) s++;
    }
    return s;
  }
  function evaluate(b, root){
    switch(strategy){
      case 'corner':   return score_corner(b, root);
      case 'mobility': return score_mobility(b, root);
      case 'count':    return score_count(b, root);
      default:         return score_balance(b, root);
    }
  }

  function alphabeta(b, depth, toMove, root, alpha, beta){
    const opp = toMove==='black'?'white':'black';
    const myMoves = validMoves(toMove, b);
    const oppMoves = validMoves(opp, b);
    if(depth===0 || (myMoves.length===0 && oppMoves.length===0)){
      return evaluate(b, root);
    }
    if(myMoves.length===0){
      return alphabeta(b, depth-1, opp, root, alpha, beta);
    }
    const maximizing = (toMove===root);
    if(maximizing){
      let best=-INF;
      for(const [r,c] of myMoves){
        const nb=cloneBoard(b); applyMove(r,c,toMove,nb);
        const val=alphabeta(nb, depth-1, opp, root, alpha, beta);
        if(val>best) best=val;
        if(val>alpha) alpha=val;
        if(beta<=alpha) break;
      }
      return best;
    }else{
      let best=INF;
      for(const [r,c] of myMoves){
        const nb=cloneBoard(b); applyMove(r,c,toMove,nb);
        const val=alphabeta(nb, depth-1, opp, root, alpha, beta);
        if(val<best) best=val;
        if(val<beta) beta=val;
        if(beta<=alpha) break;
      }
      return best;
    }
  }

  function scoreMoveWithSearch(b, r, c, player, depth){
    const root=player, opp=player==='black'?'white':'black';
    const beforeOpp = validMoves(opp, b).length;
    const nb=cloneBoard(b);
    const flips = countFlips(b, r, c, player);
    applyMove(r,c,player,nb);
    const afterOpp = validMoves(opp, nb).length;
    const mobilityDelta = beforeOpp - afterOpp;
    const long = alphabeta(nb, Math.max(0, depth-1), opp, root, -INF, INF);
    return {score: long, flips, mobilityDelta,
            isCorner:(r===0&&c===0)||(r===0&&c===SIZE-1)||(r===SIZE-1&&c===0)||(r===SIZE-1&&c===SIZE-1)};
  }

  // --- ★改良された提案計算 ---
  function calcHints(player){
    const moves=validMoves(player, board);
    const items=[];
    for(const [r,c] of moves){
      const s=scoreMoveWithSearch(board, r, c, player, cpuDepth);
      items.push({r,c,...s});
    }
    items.sort((a,b)=>b.score - a.score);
    const margin=5; // ← 不利判定のしきい値（必要に応じ調整）
    function reasonForMove(info){
      const parts=[];
      switch(strategy){
        case 'corner': parts.push(info.isCorner?"角確保":"角方向有利"); break;
        case 'mobility': parts.push(`相手の手${info.mobilityDelta>0?'-':''}${info.mobilityDelta}`); break;
        case 'count': parts.push(`獲得${info.flips}枚`); break;
        default: parts.push("石差と位置のバランス");
      }
      parts.push(`裏返し${info.flips}`);
      parts.push(`長期評価${info.score>=0?'+':''}${info.score.toFixed(1)}`);
      return parts.join(' / ');
    }
    return items.map((m,i)=>({
      r:m.r,
      c:m.c,
      rank: i<3 ? i+1 : 0,
      reason: m.score < -margin ? `長期評価が低く不利（${m.score.toFixed(1)}）` : reasonForMove(m)
    }));
  }

  function drawBoard(){
    resizeBoard();
    const el=document.getElementById('board');
    el.innerHTML='';
    const isHintTurn=(hintSide==='first'&&currentPlayer==='black')||
                     (hintSide==='second'&&currentPlayer==='white');
    const valids=validMoves(currentPlayer);
    overlayHints=isHintTurn?calcHints(currentPlayer):[];

    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const cell=document.createElement('div');
        cell.className='cell';
        cell.onclick=()=>handleMove(r,c);
        if(lastMove && lastMove.r===r && lastMove.c===c) cell.classList.add('last-move');
        if(board[r][c]){
          const disk=document.createElement('div');
          disk.className=`disk ${board[r][c]}`;
          disk.style.width='80%'; disk.style.height='80%';
          disk.style.top='10%'; disk.style.left='10%';
          cell.appendChild(disk);
        }
        const isLegal = valids.some(m=>m[0]===r && m[1]===c);
        const hint = isHintTurn && overlayHints.find(h=>h.r===r && h.c===c);
        if(hintSide==='none' && isLegal) addDot(cell);
        if(hintSide!=='none' && !isHintTurn && isLegal) addDot(cell);
        if(isHintTurn && hint){
          const overlay=document.createElement('div');
          overlay.title=hint.reason;
          overlay.className='overlay '+(hint.rank<=0?'bad':'rank'+hint.rank);
          const label=document.createElement('div');
          label.className='label'+(hint.rank<=0?' bad':'');
          label.textContent=hint.rank<=0?'×':hint.rank;
          overlay.appendChild(label);
          cell.appendChild(overlay);
        }
        el.appendChild(cell);
      }
    }
    updateScore();
  }

  function addDot(cell){
    const dot=document.createElement('div');
    dot.className='hint-dot';
    dot.style.width='15%';dot.style.height='15%';
    dot.style.top='42%';dot.style.left='42%';
    cell.appendChild(dot);
  }
  function updateScore(){
    let black=0,white=0;
    for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
      if(board[r][c]==='black') black++;
      if(board[r][c]==='white') white++;
    }
    document.getElementById('score').textContent=`黒:${black} 白:${white}`;
  }

  function other(p){return p==='black'?'white':'black';}
  function advanceTurn(){
    const opp = other(currentPlayer);
    if(validMoves(opp).length>0){ currentPlayer=opp; return; }
    if(validMoves(currentPlayer).length===0) return;
  }

  function handleMove(r,c){
    if(!validMoves(currentPlayer).some(m=>m[0]===r && m[1]===c)) return;
    history.push({board:cloneBoard(board), currentPlayer, lastMove});
    applyMove(r,c,currentPlayer);
    lastMove={r,c};
    advanceTurn();
    drawBoard();
    if(mode==='cpu' && currentPlayer==='white') aiMove();
  }
  function bestMove(player, depth){
    let best=null,bestScore=-INF;
    for(const [r,c] of validMoves(player, board)){
      const info = scoreMoveWithSearch(board, r, c, player, depth);
      if(info.score>bestScore){ bestScore=info.score; best=[r,c]; }
    }
    return best;
  }
  function aiMove(){
    if(currentPlayer!=='white') return;
    history.push({board:cloneBoard(board), currentPlayer, lastMove});
    const mv = bestMove(currentPlayer, cpuDepth);
    if(mv){
      applyMove(mv[0], mv[1], currentPlayer);
      lastMove={r:mv[0], c:mv[1]};
    }
    advanceTurn();
    drawBoard();
  }

  function undoMove(){
    if(history.length===0) return;
    const h=history.pop();
    board=h.board; currentPlayer=h.currentPlayer; lastMove=h.lastMove;
    drawBoard();
  }
  function resetGame(){
    initBoard();
    currentPlayer=firstPlayer;
    drawBoard();
    if(mode==='cpu' && currentPlayer==='white') aiMove();
  }

  function updateSettings(){
    mode=document.getElementById('mode').value;
    cpuDepth=parseInt(document.getElementById('depth').value);
    hintSide=document.getElementById('hintSide').value;
    drawBoard();
  }
  document.getElementById('mode').addEventListener('change', updateSettings);
  document.getElementById('depth').addEventListener('change', updateSettings);
  document.getElementById('hintSide').addEventListener('change', updateSettings);
  document.querySelectorAll('.strategy-btn').forEach(btn=>{
    btn.addEventListener('click', e=>{
      document.querySelectorAll('.strategy-btn').forEach(b=>b.classList.remove('active'));
      e.target.classList.add('active');
      strategy = e.target.dataset.strategy;
      drawBoard();
    });
  });
  document.getElementById('undoBtn').addEventListener('click', undoMove);
  document.getElementById('resetBtn').addEventListener('click', resetGame);
  window.addEventListener('resize', ()=>drawBoard());

  // 自動開始
  mode=document.getElementById('mode').value;
  cpuDepth=parseInt(document.getElementById('depth').value);
  hintSide=document.getElementById('hintSide').value;
  initBoard();
  currentPlayer=firstPlayer;
  drawBoard();
};
</script>
</body>
</html>
